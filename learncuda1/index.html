<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=5,viewport-fit=cover"><title>cuda编程-矩阵乘法优化 | swolf's blog</title><meta name="description" content="上一篇blog实现了一个基本的cuda程序，本篇记录如何实现矩阵乘法并加速。"><meta property="og:type" content="article"><meta property="og:title" content="cuda编程-矩阵乘法优化"><meta property="og:url" content="https://mrswolf.github.io/learncuda1/index.html"><meta property="og:site_name" content="swolf&#39;s blog"><meta property="og:description" content="上一篇blog实现了一个基本的cuda程序，本篇记录如何实现矩阵乘法并加速。"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2024-05-28T16:00:00.000Z"><meta property="article:modified_time" content="2024-06-22T16:00:00.000Z"><meta property="article:author" content="swolf"><meta property="article:tag" content="脑机接口,神经科学,机器学习,swolf,计算机,脑科学,Python,深度学习,BCI,MRI,Deep Learning"><meta name="twitter:card" content="summary"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="icon" href="/images/favicon.ico" type="image/x-icon"><meta name="google-site-verification" content="dN2SLd9-x4zqC5VsgpROSppupvj3_eOvkDfKG32YSdc"><link rel="stylesheet" href="/css/iconfont.min.css"><link rel="stylesheet" href="/css/common.min.css"><link href="//cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css" rel="stylesheet" crossorigin="anonymous"><script async src="https://www.googletagmanager.com/gtag/js?id=G-2JPFK1G1RZ"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2JPFK1G1RZ")</script><meta name="generator" content="Hexo 6.3.0"></head><body><header class="header header-fixture"><div class="profile-search-wrap flex sm:block"><div class="profile sm:text-center md:px-1 lg:px-3 sm:pb-4 sm:pt-6"><a id="avatar" role="link" href="https://mrswolf.github.io" class="inline-block lg:w-16 lg:h-16 w-8 h-8 m-2" target="_blank" rel="noopener" rel="noreferrer"><img src="/images/avatar.jpg" class="rounded-full" alt="avatar"></a><h2 id="name" class="hidden lg:block">swolf</h2><h3 id="title" class="hidden lg:block">Engineer &amp; Coder &amp; Researcher</h3><small id="location" class="hidden lg:block"><i class="iconfont icon-map-icon"></i> Earth, Universe</small></div><div class="search flex-1 flex lg:inline-block sm:hidden lg:px-4 lg:mt-2 lg:mb-4 lg:w-full"><form id="search-form" class="my-auto flex-1 lg:border lg:border-solid lg:border-gray-200"><div class="input-group table bg-gray-100 lg:bg-white w-full"><input id="search-input" type="text" placeholder="Search" class="inline-block w-full bg-gray-100 lg:bg-white p-1"> <span class="table-cell"><button name="search tigger button" disabled><i class="iconfont icon-search m-2"></i></button></span></div></form><div id="content-json" data-placeholder="Search" class="invisible hidden">/content.json</div><script id="search-teamplate" type="text/html" data-path="/content.json"><div>
        <div class="search-header bg-gray-400">
            <input id="actual-search-input" model="keyword" ref="input" class="inline-block w-full h-10 px-2 py-1" placeholder="Search" type="text">
        </div>
        <div class="search-result bg-gray-200">
            {{#each searchPosts}}
            <a href="/{{ path }}" class="result-item block px-2 pb-3 mb-1 pt-1 hover:bg-indigo-100">
                <i class="iconfont icon-file"></i>
                <h1 class="result-title inline font-medium text-lg">{{ title }}</h1>
                <p class="result-content text-gray-600 text-sm">{{{ text }}}</p>
            </a>
            {{/each}}
        </div>
    </div></script></div><button name="menu toogle button" id="menu-toggle-btn" class="block sm:hidden p-3" role="button" aria-expanded="false"><i class="iconfont icon-hamburger"></i></button></div><nav id="menu-nav" class="hidden sm:flex flex-col"><div class="menu-item menu-home" role="menuitem"><a href="/."><i class="iconfont icon-home" aria-hidden="true"></i> <span class="menu-title">Home</span></a></div><div class="menu-item menu-archives" role="menuitem"><a href="/archives"><i class="iconfont icon-archive" aria-hidden="true"></i> <span class="menu-title">Archives</span></a></div><div class="menu-item menu-categories" role="menuitem"><a href="/categories"><i class="iconfont icon-folder" aria-hidden="true"></i> <span class="menu-title">Categories</span></a></div><div class="menu-item menu-tags" role="menuitem"><a href="/tags"><i class="iconfont icon-tag" aria-hidden="true"></i> <span class="menu-title">Tags</span></a></div><div class="menu-item menu-repository" role="menuitem"><a href="/repository"><i class="iconfont icon-project" aria-hidden="true"></i> <span class="menu-title">Repository</span></a></div><div class="menu-item menu-publications" role="menuitem"><a href="/publications"><i class="iconfont icon-folder" aria-hidden="true"></i> <span class="menu-title">Publications</span></a></div><div class="menu-item menu-about" role="menuitem"><a href="/about"><i class="iconfont icon-cup" aria-hidden="true"></i> <span class="menu-title">About</span></a></div><div class="social-links flex sm:flex-col lg:hidden mt-5"><span class="social-item text-center"><a target="_blank" rel="noopener" href="https://github.com/mrswolf"><i class="iconfont social-icon icon-github"></i> <span class="menu-title hidden lg:inline">menu.github</span> </a></span><span class="social-item text-center"><a href="/atom.xml"><i class="iconfont social-icon icon-rss"></i> <span class="menu-title hidden lg:inline">menu.rss</span></a></span></div></nav></header><section class="main-section"><main class="flex-1 px-4 py-14 md:px-5 lg:px-8 lg:py-4 relative min-h-screen"><article class="content article article-archives article-type-list" itemscope><header class="article-header"><h1 itemprop="name text-lg"><a class="article-title" href="/learncuda1" target="_blank" itemprop="url">cuda编程-矩阵乘法优化</a></h1><p class="article-meta mb-3 text-xs"><span class="article-date"><i class="iconfont icon-calendar-check"></i><time datetime="2024-05-28T16:00:00.000Z" itemprop="datePublished">May29, 2024</time></span><span class="article-date"><i class="iconfont icon-calendar-check"></i><time datetime="2024-06-22T16:00:00.000Z" itemprop="datePublished">Jun23, 2024</time></span><span class="article-category"><i class="iconfont icon-folder"></i> <a class="article-category-link" href="/categories/cuda/">cuda</a> </span><span class="_partial/post-comment"><i class="icon icon-comment"></i> <a href="/learncuda1/#comments" class="article-comment-link">Comments </a></span><span class="post-wordcount" itemprop="wordCount">Word Count: 2.2k(words)</span> <span class="post-readcount" itemprop="timeRequired">Read Count: 9(minutes)</span></p></header><div class="marked-body article-body"><p>上一篇blog实现了一个基本的cuda程序，本篇记录如何实现矩阵乘法并加速。<span id="more"></span>主要内容是对<a target="_blank" rel="noopener" href="https://siboehm.com/articles/22/CUDA-MMM">blog</a>内容的学习和复现，目的是逐步逼近cuBLAS实现的单精度矩阵乘法：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">C</mi><mo>=</mo><mi>α</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">B</mi><mo>+</mo><mi>β</mi><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} = \alpha \mathbf{A}\mathbf{B} + \beta \mathbf{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">C</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7694em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mord mathbf">AB</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mord mathbf">C</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>M</mi><mo>×</mo><mi>K</mi></mrow></msup><mo separator="true">,</mo><mi mathvariant="bold">B</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>K</mi><mo>×</mo><mi>N</mi></mrow></msup><mo separator="true">,</mo><mi mathvariant="bold">C</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A}\in \mathbb{R}^{M \times K},\mathbf{B}\in \mathbb{R}^{K \times N},\mathbf{C}\in \mathbb{R}^{M \times N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7252em;vertical-align:-.0391em"></span><span class="mord mathbf">A</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.0358em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathbf">B</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.0358em;vertical-align:-.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:.10903em">N</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathbf">C</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8413em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:.10903em">N</span></span></span></span></span></span></span></span></span></span></span></span>。源代码在<a target="_blank" rel="noopener" href="https://github.com/Mrswolf/blog_code/tree/main/learncuda">这里</a>。</p><h3 id="Naive-vs-cuBLAS">Naive vs cuBLAS</h3><p>因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><mo>=</mo><mi>α</mi><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>K</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi mathvariant="bold">A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><msub><mi mathvariant="bold">B</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mi>β</mi><mi mathvariant="bold">C</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}{i,j} = \alpha \sum_{k=0}^{K-1} \mathbf{A}_{i,k} \mathbf{B}_{k,j} + \beta \mathbf{C}{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8805em;vertical-align:-.1944em"></span><span class="mord mathbf">C</span><span class="mord"><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.2809em;vertical-align:-.2997em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mspace" style="margin-right:.1667em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.9812em"><span style="top:-2.4003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2997em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathbf">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2861em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mord mathbf">C</span><span class="mord"><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span></span>，很容易我们可以想到为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">C</span></span></span></span>的每个元素分配一个thread计算值并输出：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">sgemm_naive</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> K, <span class="type">const</span> <span class="type">float</span> alpha, <span class="type">const</span> <span class="type">float</span> *A, <span class="type">const</span> <span class="type">float</span> *B, <span class="type">const</span> <span class="type">float</span> beta, <span class="type">float</span> *C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> j = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// avoids memory access error if threads are more than elements</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; M &amp;&amp; j &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i * K + k] * B[k * N + j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i * N + j] = alpha * sum + beta * C[i * N + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">gridDim</span><span class="params">((M - <span class="number">1</span>) / <span class="number">32</span> + <span class="number">1</span>, (N - <span class="number">1</span>) / <span class="number">32</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">blockDim</span><span class="params">(<span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">sgemm_naive&lt;&lt;&lt;gridDim, blockDim&gt;&gt;&gt;(M, N, K, alpha, d_A, d_B, beta, d_C);</span><br></pre></td></tr></table></figure><p>block的数目要确保了能覆盖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">C</span></span></span></span>的所有元素，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M,N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8778em;vertical-align:-.1944em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span></span></span></span>不能被32（这里简单的让x和y方向上的thread数目相等，当然也可以分别选择不同的值）整除时，边缘处总有一些threads在空跑，这是无法避免的。<code>sgemm_naive</code>的各项指标如下：</p><ul><li>总浮点数操作：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>N</mi><mo stretchy="false">(</mo><mn>2</mn><mi>K</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MN(2K+3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">MN</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></li><li>总显存访问次数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>N</mi><mo stretchy="false">(</mo><mn>2</mn><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MN(2K+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">MN</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>总显存占用：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>M</mi><mi>N</mi><mo>+</mo><mi>M</mi><mi>K</mi><mo>+</mo><mi>K</mi><mi>M</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>4</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">(MN+MK+KM)*4B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.10903em">MN</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.7667em;vertical-align:-.0833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span></li></ul><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>N</mi><mo>=</mo><mi>K</mi><mo>=</mo><mn>4096</mn></mrow><annotation encoding="application/x-tex">M=N=K=4096</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">4096</span></span></span></span>时，总浮点数操作为137.5GFLOPS，GTX1080的FP32运算能力是8.873TFLOPS，最好情况下可以在15.5ms左右完成<code>sgemm</code>。要存储矩阵并完成计算，理想情况下总显存占用为201.3MB，GTX1080显存8GB，因此显存大小是没有问题的。不过，总显存访问次数计算出的显存通量是549.8GB，而GTX1080的带宽峰值是320GB/s，因此完成这么多次显存访问总共需要1.718s，远远大于实际计算时间。<code>sgemm_naive</code>的运行时间完全由显存访问主导，大部分时间GPU核心都在等待数据。实际运行中只会更慢，在我的电脑上，<code>sgemm_naive</code>大概需要2900ms。</p><p>而<code>cublasSgemm</code>呢，只需要大约20ms，接近15ms的理论极限，快的惊人！</p><h3 id="Memory-Coalescing">Memory Coalescing</h3><p>在基本概念中我们提到GPU会把block中每32个thread组成一个warp交由硬件调度，考虑一个32x32的block，那么到底是row上的32个threads组成warp还是column上的32个threads组成warp？事实上，针对多维情况，会首先转化成1维，并取连续的32个threads组成warp。对于三元组（x,y,z）CUDA的规则是x优先，每个block中的全局threadId由下式确定：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>I</mi><mi>d</mi><mo>=</mo><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>I</mi><mi>d</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>D</mi><mi>i</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>∗</mo><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>I</mi><mi>d</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo>+</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>D</mi><mi>i</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>∗</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>D</mi><mi>i</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo>∗</mo><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>I</mi><mi>d</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">threadId = threadIdx.x + blockDim.x * threadIdx.y + blockDim.x * blockDim.y * threadIdx.z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7778em;vertical-align:-.0833em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="mord mathnormal">im</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="mord mathnormal">im</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mord mathnormal" style="margin-right:.02778em">D</span><span class="mord mathnormal">im</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span></span></p><p>warp的特点之一是如果这些threads读取的是同样的数据，会触发一种within-warp broadcast的共享机制，实际上不需要每个thread都重新读取数据，因此会显著减小开销。另一个特点是这些threads读取显存时可以一次性读取大量连续数据（比如32B、64B、128B）到更快的内存上（例如L2 cache）。例如一个warp中的32个thread可以选择各自读取1个浮点数（4B），需要操作32次，但如果他们读的是一块连续的内存，实际上可以用一个128B的读取指令等价，只需操作一次，直接加速32倍。满足memory coalescing的程序就会去尽量利用这种机制，让一个warp里的threads去利用一块相近的而内存区域。</p><p>那么<code>sgemm_naive</code>是不是memory coalescing的呢？首先我们要明确，在当前的例子中，C++采取row-major的存储顺序，即矩阵的每一行在内存中是连续的。我们当前的block大小是32x32，正好每32个threads组成一个warp。而这个wrap中的threads都是threadIdx.y不变而threadIdx.x递增。根据我们对于每个thread与元素的映射规则：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = blockIdx.y * blockDim.y + threadIdx.y;</span><br></pre></td></tr></table></figure><p>i递增而j不变，因此程序会不断读取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>的第j列和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>不同i行。根据warp的特点，读取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>的列会触发within-warp broadcast，因此尽管列中的元素不是连续存储的，threads读取这些元素的开销很小；但是对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>，尽管每一行是连续的内存，但每个thread用的是来自不同行的数据，同一时刻读取的元素（每一列中的32个元素）在内存里是不连续的，自然无法满足memory coalescing的要求。</p><p>因此，应当尽量使threadIdx.x的变化同内存排序一致，我们只需要交换xy的方向：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> j = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = blockIdx.y * blockDim.y + threadIdx.y;</span><br></pre></td></tr></table></figure><p>此时，同一个warp里j递增而i不变，程序会反复读取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>的第i行和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>的不同列。读取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>的行会触发within-warp broadcast，而对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>而言，同一时刻每个thread读取的元素在内存中是连续的，满足memory coalescing的要求。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">sgemm_coalesce</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> K, <span class="type">const</span> <span class="type">float</span> alpha, <span class="type">const</span> <span class="type">float</span> *A, <span class="type">const</span> <span class="type">float</span> *B, <span class="type">const</span> <span class="type">float</span> beta, <span class="type">float</span> *C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> j = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// avoids memory access error if threads are more than elements</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; M &amp;&amp; j &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; K; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i * K + k] * B[k * N + j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i * N + j] = alpha * sum + beta * C[i * N + j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sgemm_coalesce</code>只需要392ms。</p><h3 id="Tiled-Matrix-Multiply-with-Shared-Memory">Tiled Matrix Multiply with Shared Memory</h3><p><code>sgemm_coalesce</code>的主要开销还是由从全局内存读取数据的次数决定。一种改进思路是用shared memory实现tiled matrix multiply。tiled matrix multiply通过把数据分块，一次性读取分块数据到更快的内存上（认为更快的内存访问时间可以忽略不计），从而减小整体全局内存访问的开销。假设缓存的大小是B x B，则总显存访问次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>N</mi><mo stretchy="false">(</mo><mn>2</mn><mi>K</mi><mi mathvariant="normal">/</mi><mi>B</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MN(2K/B+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">MN</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，因此B越大，访问全局内存的时间开销就越少。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKSIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">sgemm_shared</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> K, <span class="type">const</span> <span class="type">float</span> alpha, <span class="type">const</span> <span class="type">float</span> *A, <span class="type">const</span> <span class="type">float</span> *B, <span class="type">const</span> <span class="type">float</span> beta, <span class="type">float</span> *C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __shared__ <span class="type">float</span> As[BLOCKSIZE * BLOCKSIZE];</span><br><span class="line">    __shared__ <span class="type">float</span> Bs[BLOCKSIZE * BLOCKSIZE];</span><br><span class="line"></span><br><span class="line">    A += blockIdx.y * BLOCKSIZE * K;</span><br><span class="line">    B += blockIdx.x * BLOCKSIZE;</span><br><span class="line">    C += blockIdx.y * BLOCKSIZE * N + blockIdx.x * BLOCKSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> j = blockIdx.x * BLOCKSIZE + threadIdx.x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i = blockIdx.y * BLOCKSIZE + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// avoids memory access error if threads are more than elements</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; M &amp;&amp; j &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> fSum = <span class="number">0.0f</span>; <span class="comment">// stores result of (threadIdx.y, threadIdx.x) on each block</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> iBlkIdx = <span class="number">0</span>; iBlkIdx &lt; K; iBlkIdx += BLOCKSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (iBlkIdx + threadIdx.x &lt; K)</span><br><span class="line">            &#123;</span><br><span class="line">                As[threadIdx.y * BLOCKSIZE + threadIdx.x] = A[threadIdx.y * K + threadIdx.x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (iBlkIdx + threadIdx.y &lt; K)</span><br><span class="line">            &#123;</span><br><span class="line">                Bs[threadIdx.y * BLOCKSIZE + threadIdx.x] = B[threadIdx.y * N + threadIdx.x];</span><br><span class="line">            &#125;</span><br><span class="line">            __syncthreads(); <span class="comment">// syncronize until  all caches are fulfilled</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// updates to the next chunk</span></span><br><span class="line">            A += BLOCKSIZE;</span><br><span class="line">            B += BLOCKSIZE * N;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// dot product on caches</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> iInnerLoop = <span class="number">0</span>; iInnerLoop &lt; BLOCKSIZE; ++iInnerLoop)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (iBlkIdx + iInnerLoop &lt; K)</span><br><span class="line">                &#123;</span><br><span class="line">                    fSum += As[threadIdx.y * BLOCKSIZE + iInnerLoop] * Bs[iInnerLoop * BLOCKSIZE + threadIdx.x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            __syncthreads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        C[threadIdx.y * N + threadIdx.x] = alpha * fSum + beta * C[threadIdx.y * N + threadIdx.x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的核函数各为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>分配了32 x 32的shared memory，同一个block中的threads都可以访问。这里我们假设block的大小就是(32, 32, 1)，因此block中的每一个thread可以通过(threadIdx.x, threadIdx.y)对应shared memory中的一个元素，也对应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">C</span></span></span></span>中的一个输出元素。</p><p>block中的thread有三种工作：1、读取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>中的对应块位置元素到shared memory，等待直到所有threads完成元素读取；2、block中的每个thread使用shared memory执行分块矩阵乘法，并累加计算的结果；3、移动分块在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>中的位置，重复1和2的工作，直到block所对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">A</span></span></span></span>的行和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">B</span></span></span></span>的列都遍历结束，最终将值写入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">C</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6861em"></span><span class="mord mathbf">C</span></span></span></span>中。</p><p>此外，也需要考虑矩阵大小不能被block大小整除的情况，通过边界条件来控制thread的计算。<code>sgemm_shared</code>的执行时间为147ms。</p></div><blockquote class="copyright"><p><strong>Link to this article : </strong><a class="permalink" href="https://mrswolf.github.io/learncuda1/">https://mrswolf.github.io/learncuda1/</a></p><p><strong>This article is available under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a> License</strong></p></blockquote></article></main><aside id="sidebar" class="aside aside-fixture"><div class="toc-sidebar"><nav id="toc" class="article-toc"><h3 class="toc-title">Catalogue</h3><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Naive-vs-cuBLAS"><span class="toc-number">1.</span> <span class="toc-text">Naive vs cuBLAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Coalescing"><span class="toc-number">2.</span> <span class="toc-text">Memory Coalescing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tiled-Matrix-Multiply-with-Shared-Memory"><span class="toc-number">3.</span> <span class="toc-text">Tiled Matrix Multiply with Shared Memory</span></a></li></ol></nav></div></aside></section><footer class="hidden lg:block fixed bottom-0 left-0 sm:w-1/12 lg:w-1/6 bg-gray-100 z-40"><div class="footer-social-links"><a target="_blank" rel="noopener" href="https://github.com/mrswolf"><i class="iconfont icon-github"></i> </a><a href="/atom.xml"><i class="iconfont icon-rss"></i></a></div></footer><div id="mask" class="hidden mask fixed inset-0 bg-gray-900 opacity-75 z-40"></div><div id="search-view-container" class="hidden shadow-xl"></div><script src="/js/dom-event.min.js"></script><script src="/js/local-search.min.js"></script><script src="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/js/lightgallery.min.js"></script><script src="/js/light-gallery.min.js"></script></body></html>