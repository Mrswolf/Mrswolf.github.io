<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=5,viewport-fit=cover"><title>CMake Cheatsheet | swolf's blog</title><meta name="description" content="CMake is a popular cross-platform build system that allows developers to use a common interface to define a set of rules to build the source code with different compilers, such as GCC, Clang and Visu"><meta property="og:type" content="article"><meta property="og:title" content="CMake Cheatsheet"><meta property="og:url" content="https://mrswolf.github.io/learncmake/index.html"><meta property="og:site_name" content="swolf&#39;s blog"><meta property="og:description" content="CMake is a popular cross-platform build system that allows developers to use a common interface to define a set of rules to build the source code with different compilers, such as GCC, Clang and Visu"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2024-05-22T16:00:00.000Z"><meta property="article:modified_time" content="2024-06-23T16:00:00.000Z"><meta property="article:author" content="swolf"><meta property="article:tag" content="脑机接口,神经科学,机器学习,swolf,计算机,脑科学,Python,深度学习,BCI,MRI,Deep Learning"><meta name="twitter:card" content="summary"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="icon" href="/images/favicon.ico" type="image/x-icon"><meta name="google-site-verification" content="dN2SLd9-x4zqC5VsgpROSppupvj3_eOvkDfKG32YSdc"><link rel="stylesheet" href="/css/iconfont.min.css"><link rel="stylesheet" href="/css/common.min.css"><link href="//cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css" rel="stylesheet" crossorigin="anonymous"><script async src="https://www.googletagmanager.com/gtag/js?id=G-2JPFK1G1RZ"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-2JPFK1G1RZ")</script><meta name="generator" content="Hexo 6.3.0"></head><body><header class="header header-fixture"><div class="profile-search-wrap flex sm:block"><div class="profile sm:text-center md:px-1 lg:px-3 sm:pb-4 sm:pt-6"><a id="avatar" role="link" href="https://mrswolf.github.io" class="inline-block lg:w-16 lg:h-16 w-8 h-8 m-2" target="_blank" rel="noopener" rel="noreferrer"><img src="/images/avatar.jpg" class="rounded-full" alt="avatar"></a><h2 id="name" class="hidden lg:block">swolf</h2><h3 id="title" class="hidden lg:block">Engineer &amp; Coder &amp; Researcher</h3><small id="location" class="hidden lg:block"><i class="iconfont icon-map-icon"></i> Earth, Universe</small></div><div class="search flex-1 flex lg:inline-block sm:hidden lg:px-4 lg:mt-2 lg:mb-4 lg:w-full"><form id="search-form" class="my-auto flex-1 lg:border lg:border-solid lg:border-gray-200"><div class="input-group table bg-gray-100 lg:bg-white w-full"><input id="search-input" type="text" placeholder="Search" class="inline-block w-full bg-gray-100 lg:bg-white p-1"> <span class="table-cell"><button name="search tigger button" disabled><i class="iconfont icon-search m-2"></i></button></span></div></form><div id="content-json" data-placeholder="Search" class="invisible hidden">/content.json</div><script id="search-teamplate" type="text/html" data-path="/content.json"><div>
        <div class="search-header bg-gray-400">
            <input id="actual-search-input" model="keyword" ref="input" class="inline-block w-full h-10 px-2 py-1" placeholder="Search" type="text">
        </div>
        <div class="search-result bg-gray-200">
            {{#each searchPosts}}
            <a href="/{{ path }}" class="result-item block px-2 pb-3 mb-1 pt-1 hover:bg-indigo-100">
                <i class="iconfont icon-file"></i>
                <h1 class="result-title inline font-medium text-lg">{{ title }}</h1>
                <p class="result-content text-gray-600 text-sm">{{{ text }}}</p>
            </a>
            {{/each}}
        </div>
    </div></script></div><button name="menu toogle button" id="menu-toggle-btn" class="block sm:hidden p-3" role="button" aria-expanded="false"><i class="iconfont icon-hamburger"></i></button></div><nav id="menu-nav" class="hidden sm:flex flex-col"><div class="menu-item menu-home" role="menuitem"><a href="/."><i class="iconfont icon-home" aria-hidden="true"></i> <span class="menu-title">Home</span></a></div><div class="menu-item menu-archives" role="menuitem"><a href="/archives"><i class="iconfont icon-archive" aria-hidden="true"></i> <span class="menu-title">Archives</span></a></div><div class="menu-item menu-categories" role="menuitem"><a href="/categories"><i class="iconfont icon-folder" aria-hidden="true"></i> <span class="menu-title">Categories</span></a></div><div class="menu-item menu-tags" role="menuitem"><a href="/tags"><i class="iconfont icon-tag" aria-hidden="true"></i> <span class="menu-title">Tags</span></a></div><div class="menu-item menu-repository" role="menuitem"><a href="/repository"><i class="iconfont icon-project" aria-hidden="true"></i> <span class="menu-title">Repository</span></a></div><div class="menu-item menu-publications" role="menuitem"><a href="/publications"><i class="iconfont icon-folder" aria-hidden="true"></i> <span class="menu-title">Publications</span></a></div><div class="menu-item menu-about" role="menuitem"><a href="/about"><i class="iconfont icon-cup" aria-hidden="true"></i> <span class="menu-title">About</span></a></div><div class="social-links flex sm:flex-col lg:hidden mt-5"><span class="social-item text-center"><a target="_blank" rel="noopener" href="https://github.com/mrswolf"><i class="iconfont social-icon icon-github"></i> <span class="menu-title hidden lg:inline">menu.github</span> </a></span><span class="social-item text-center"><a href="/atom.xml"><i class="iconfont social-icon icon-rss"></i> <span class="menu-title hidden lg:inline">menu.rss</span></a></span></div></nav></header><section class="main-section"><main class="flex-1 px-4 py-14 md:px-5 lg:px-8 lg:py-4 relative min-h-screen"><article class="content article article-archives article-type-list" itemscope><header class="article-header"><h1 itemprop="name text-lg"><a class="article-title" href="/learncmake" target="_blank" itemprop="url">CMake Cheatsheet</a></h1><p class="article-meta mb-3 text-xs"><span class="article-date"><i class="iconfont icon-calendar-check"></i><time datetime="2024-05-22T16:00:00.000Z" itemprop="datePublished">May23, 2024</time></span><span class="article-date"><i class="iconfont icon-calendar-check"></i><time datetime="2024-06-23T16:00:00.000Z" itemprop="datePublished">Jun24, 2024</time></span><span class="article-category"><i class="iconfont icon-folder"></i> <a class="article-category-link" href="/categories/c/">c++</a> </span><span class="_partial/post-comment"><i class="icon icon-comment"></i> <a href="/learncmake/#comments" class="article-comment-link">Comments </a></span><span class="post-wordcount" itemprop="wordCount">Word Count: 1.9k(words)</span> <span class="post-readcount" itemprop="timeRequired">Read Count: 11(minutes)</span></p></header><div class="marked-body article-body"><p>CMake is a popular cross-platform build system that allows developers to use a common interface to define a set of rules to build the source code with different compilers, such as GCC, Clang and Visual Studio. In fact, CMake supports not only C/C++, but also other languages such as C# and Fortran. CMake is an essential tool for building software projects and making the whole process easier for anyone. <span id="more"></span></p><p>I put my code <a target="_blank" rel="noopener" href="https://github.com/Mrswolf/blog_code/tree/main/cmake">here</a>.</p><h2 id="Basic">Basic</h2><h3 id="How-to-start">How to start</h3><p>After you install CMake, the starting point is to create a <code>CMakeLists.txt</code> file. <strong>Three</strong> basic commands are required for the minimum build process. Below is a basic <code>CMakeLists.txt</code> file template:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld VERSION <span class="number">1.0</span> LANGUAGES C CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(helloworld main.cpp)</span><br></pre></td></tr></table></figure><p>Don’t forget to create a source file named <code>main.cpp</code> alongside with the <code>CMakeLists.txt</code> file:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;HELLO CMAKE!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To build the project, open the terminal where you create your <code>CMakeList.txt</code> file, create a new folder <code>mkdir build &amp;&amp; cd build</code> and just type <code>cmake ..</code>. CMake would output a bunch of files for building the system, the last step is to actually compile&amp;link the project. Depending on the underlying generators, we could build the project with <code>make</code> or <code>ninja</code> or a more general command <code>cmake --build . --config Release</code>. The default behavior is to generate an executable object with release configs on the current folder. Type <code>./helloworld</code> to run the program.</p><p>CMake uses the jargon <strong>target</strong> refering to those final executable objects or libraries, e.g. <code>helloworld</code> in this demo. <code>LANGUAGES C CXX</code> specifies the programming languages needed to build the project. <code>CMAKE_CXX_STANDARD</code> specifies the c++ standard to build the project.</p><h3 id="How-to-find-headers">How to find headers</h3><p>So far we have only compiled one source file, but what if we have hundreds of source files and header files scattered across multiple directories? I created a folder structure looks like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">includes/</span><br><span class="line">  algo.h</span><br><span class="line">algo.cpp</span><br><span class="line">main.cpp</span><br><span class="line">CMakeLists.txt</span><br></pre></td></tr></table></figure><p>To compile this project, we tell CMake that we also need to compile <code>algo.cpp</code> and <code>algo.h</code>:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld VERSION <span class="number">1.0</span> LANGUAGES C CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(helloworld main.cpp algo.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(helloworld PRIVATE includes)</span><br></pre></td></tr></table></figure><p><code>target_include_directories</code> refers to where to seach for additional headers, the <code>includes</code> directory in this case. And <code>PRIVATE</code> refers to that these header files are only visible for the target <code>helloworld</code>, not for any target linking against the target defined here (if <code>helloworld</code> is a library). <code>include_directories</code> acts as the same purpose but for all targets in the current CMakeLists.</p><h3 id="How-to-collect-all-sources">How to collect all sources</h3><p>Instead of manual settings, an easy way to get all cpp files is to use <code>file</code> command:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld VERSION <span class="number">1.0</span> LANGUAGES C CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCES *.cpp utils/*.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(helloworld <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(helloworld PRIVATE includes)</span><br></pre></td></tr></table></figure><p>which collects files under the current and <code>utils</code> directories with the postfix <code>.cpp</code> and stores into the variable <code>SOURCES</code>.</p><p>Another way to collect all source files is to use command <code>aux_source_directory</code> like this:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(HelloWorld VERSION <span class="number">1.0</span> LANGUAGES C CXX)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(.  utils SOURCES)</span><br><span class="line"><span class="keyword">add_executable</span>(helloworld <span class="variable">$&#123;SOURCES&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(helloworld PRIVATE includes)</span><br></pre></td></tr></table></figure><h3 id="How-to-add-definitions">How to add definitions</h3><p>It’s normal to add preprocessor definitions to control the compiling process. Before version 3.12, CMake used command <code>add_definitions</code> which affects all targets in the current directory and subdirectories, even if you don’t want to. In version 3.12, CMake introduced a new command <code>add_compile_definitions</code> which is more specific to targets in the current CMakeLists. It’s generally recommended to move towards to the new command.</p><p>The following code defines <code>EXPORT_DLL</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_definitions(-DEXPORT_DLL)</span><br><span class="line">add_compile_definitions(EXPORT_DLL)</span><br></pre></td></tr></table></figure><p>It’s also possible to add definitions to a specific target:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_compile_definitions(helloworld PRIVATE EXPORT_DLL)</span><br></pre></td></tr></table></figure><h3 id="How-to-pass-compiler-flags">How to pass compiler flags</h3><p>Sometimes we want to control the compiler behaviors more precisely. CMake has <code>add_compile_options</code> for all targets in the current directory and subdirectories, and <code>targe_compile_options</code> for a specific target.</p><p>The following code tells gcc/g++ to use <code>O3</code> optimization level and generate debug information to be used by GDB:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_compile_options(-O3)</span><br><span class="line">target_compile_options(helloworld PRIVATE -g)</span><br></pre></td></tr></table></figure><h3 id="How-to-designate-output-folders">How to designate output folders</h3><p>There are some predefined variables to specifies the output directories:</p><ul><li><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code> refers to where to put executable files (<code>.exe</code>) created by <code>add_executable</code> or <code>.dll</code> created by <code>add_library</code> with <code>SHARED</code> on Windows platform</li><li><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code> refers to where to put shared libraries (<code>.so</code>) created by <code>add_library</code> with <code>SHARED</code> option on Linux platform</li><li><code>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</code> refers to where to put static libraries (<code>.a</code>, <code>.lib</code>) created by <code>add_library</code> with <code>STATIC</code> option or <code>.lib</code> created by <code>add_library</code> with <code>SHARED</code> option on Windows platform</li></ul><p>CMake also has a few useful variables to specify directories:</p><ul><li><code>CMAKE_SOURCE_DIR</code> contains the directory where the called <code>CMakeLists</code> exists</li><li><code>CMAKE_BINARY_DIR</code> contains the directory where you generate those temporary files to build the project</li></ul><p>For our helloworld project, the executable <code>helloworld</code> would be put under the <code>lib</code> folder:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.12)</span><br><span class="line">project(HelloWorld VERSION 1.0 LANGUAGES C CXX)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">file(GLOB SOURCES &quot;*.cpp&quot; &quot;utils/*.cpp&quot;)</span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">add_executable(helloworld $&#123;SOURCES&#125;)</span><br><span class="line">target_include_directories(helloworld PRIVATE includes)</span><br></pre></td></tr></table></figure><h3 id="How-to-compile-static-libraries">How to compile static libraries</h3><p>Just use <code>add_library</code> instead of <code>add_executable</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.12)</span><br><span class="line">project(stalib VERSION 1.0 LANGUAGES C CXX)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">aux_source_directory(. SOURCES)</span><br><span class="line">add_library(stalib STATIC $&#123;SOURCES&#125;)</span><br></pre></td></tr></table></figure><p>This CMakeLists builds a static library <code>libstalib.a</code>.</p><h3 id="How-to-compile-shared-libraries">How to compile shared libraries</h3><p>I also made a new folder <code>dynlib</code> under my <code>helloword</code> project. CMake compiles shared libraries by <code>add_library</code> command with <code>SHARED</code> option:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.12)</span><br><span class="line">project(dynlib VERSION 1.0 LANGUAGES C CXX)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">aux_source_directory(. SOURCES)</span><br><span class="line">add_library(dynlib SHARED $&#123;SOURCES&#125;)</span><br><span class="line">target_compile_definitions(dynlib PRIVATE EXPORT_DLL)</span><br><span class="line">target_compile_options(dynlib PRIVATE -fvisibility=hidden -fvisibility-inlines-hidden)</span><br></pre></td></tr></table></figure><p>The above config generates <code>libdynlib.so</code>, which can be linked into a larger program.</p><p>By default, Linux exports all symbols when compiles a shared library. However, Windows does the opposite thing. To control the visibility of symbols on Linux, we could add <code>-fvisibility=hidden -fvisibility-inlines-hidden</code> to the compiler to make sure all symbols unvisible, until we make it explicitly by adding <code>__attribute__((visibility('default')))</code> before symbols (Windows uses <code>__declspec(dllexport)</code> and <code>__declspec(dllimport)</code>). This would greatly reduce the chance of symbol collision. For compatible code, we could use <a target="_blank" rel="noopener" href="https://gcc.gnu.org/wiki/Visibility">macro definitions</a>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined _WIN32 || defined __CYGWIN__</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HELPER_DLL_IMPORT __declspec(dllimport)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HELPER_DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> HELPER_DLL_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> __GNUC__ &gt;= 4</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> HELPER_DLL_IMPORT __attribute__ ((visibility (<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> HELPER_DLL_EXPORT __attribute__ ((visibility (<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> HELPER_DLL_LOCAL  __attribute__ ((visibility (<span class="string">&quot;hidden&quot;</span>)))</span></span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> HELPER_DLL_IMPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> HELPER_DLL_EXPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> HELPER_DLL_LOCAL</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXPORT_ALL</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> DLL_API HELPER_DLL_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> DLL_API HELPER_DLL_IMPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_API <span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure><p>Use command <code>nm -C -D libdynlib.so</code> to list all exported symbols:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">0000000000001199 T hello()</span><br><span class="line">                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))@GLIBCXX_3.4</span><br><span class="line">                 U std::ostream::operator&lt;&lt;(int)@GLIBCXX_3.4</span><br></pre></td></tr></table></figure><p>we can see that <code>void hello(int i)</code> is not exported.</p><h3 id="How-to-link-libraries">How to link libraries</h3><p>Use <code>target_link_libraries</code> to link static and shared libraries for a single target:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.12)</span><br><span class="line">project(HelloWorld VERSION 1.0 LANGUAGES C CXX)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">file(GLOB SOURCES &quot;*.cpp&quot; &quot;utils/*.cpp&quot;)</span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">add_executable(helloworld $&#123;SOURCES&#125;)</span><br><span class="line">target_include_directories(helloworld PRIVATE includes)</span><br><span class="line">target_link_libraries(helloworld PRIVATE stalib dynlib)</span><br></pre></td></tr></table></figure><p>or <code>link_libraries</code> which affects all targets created later in the current directory and subdirectories.</p><h3 id="How-to-add-library-seaching-paths">How to add library seaching paths</h3><p>It’s also common to add library seaching paths. CMake uses <code>link_directories</code> and <code>target_link_directories</code> (available in version 3.13) to add library paths, for targets created later and a single target, respectively.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.12)</span><br><span class="line">project(HelloWorld VERSION 1.0 LANGUAGES C CXX)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">file(GLOB SOURCES &quot;*.cpp&quot; &quot;utils/*.cpp&quot;)</span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">add_executable(helloworld $&#123;SOURCES&#125;)</span><br><span class="line">target_include_directories(helloworld PRIVATE includes)</span><br><span class="line">target_link_directories(helloworld PRIVATE $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">target_link_libraries(helloworld PRIVATE stalib dynlib)</span><br></pre></td></tr></table></figure><p>These library searching paths can be found in a preset variable <code>CMAKE_LIBRARY_PATH</code>.</p><h3 id="How-to-compile-multiple-targets-on-a-single-CMakeLists">How to compile multiple targets on a single CMakeLists</h3><p><code>add_subdirectory</code> searches available CMakeLists on the subdirectory so that it can be compiled on the top-level called CMakeLists:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.13)</span><br><span class="line">project(HelloWorld VERSION 1.0 LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line">add_subdirectory(dynlib)</span><br><span class="line">add_subdirectory(stalib)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">file(GLOB SOURCES &quot;*.cpp&quot; &quot;utils/*.cpp&quot;)</span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">add_executable(helloworld $&#123;SOURCES&#125;)</span><br><span class="line">target_include_directories(helloworld PRIVATE includes)</span><br><span class="line">target_link_directories(helloworld PRIVATE $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line">target_link_libraries(helloworld PRIVATE stalib dynlib)</span><br></pre></td></tr></table></figure><p>This CMakeLists firstly builds two libraries and then build the executable object <code>helloworld</code>, which links these libraries.</p><h3 id="How-to-compile-a-CUDA-program">How to compile a CUDA program</h3><p>CMake automatically triggers <code>nvcc</code> for compiling files with the <code>.cu</code> extension. I would compile a cuda kernel funtion into <code>dynlib</code> and call it in the main program. To do that, I created a new <code>dyncuda.cu</code> file:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dynlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_CUDA_ERROR(val) check((val), #val, __FILE__, __LINE__)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(cudaError_t err, <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> func, <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> file,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;CUDA Runtime Error at: &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line</span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="built_in">cudaGetErrorString</span>(err) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; func &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// We don&#x27;t exit when we encounter CUDA errors in this example.</span></span><br><span class="line">        <span class="comment">// std::exit(EXIT_FAILURE);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_LAST_CUDA_ERROR() checkLast(__FILE__, __LINE__)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkLast</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> file, <span class="type">const</span> <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cudaError_t <span class="type">const</span> err&#123;<span class="built_in">cudaGetLastError</span>()&#125;;</span><br><span class="line">    <span class="keyword">if</span> (err != cudaSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;CUDA Runtime Error at: &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line</span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="built_in">cudaGetErrorString</span>(err) &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// We don&#x27;t exit when we encounter CUDA errors in this example.</span></span><br><span class="line">        <span class="comment">// std::exit(EXIT_FAILURE);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">cudahello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello cuda\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cudaHelloLaunch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cudahello&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    <span class="built_in">CHECK_CUDA_ERROR</span>(<span class="built_in">cudaDeviceSynchronize</span>());</span><br><span class="line">    <span class="built_in">CHECK_LAST_CUDA_ERROR</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and its header looks like:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">cudahello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DLL_API <span class="type">void</span> <span class="title">cudaHelloLaunch</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>In this way, the cuda kernel function would be launched by a cpp wrapper function exported to other programs. CMakeLists compiling the CUDA program looks like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.13)</span><br><span class="line">project(dynlib VERSION 1.0 LANGUAGES C CXX CUDA)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line">if(NOT DEFINED CMAKE_CUDA_ARCHITECTURES)</span><br><span class="line">  set(CMAKE_CUDA_ARCHITECTURES 61;70)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line">aux_source_directory(. SOURCES)</span><br><span class="line">add_library(dynlib SHARED $&#123;SOURCES&#125;)</span><br><span class="line">target_compile_definitions(dynlib PRIVATE EXPORT_DLL)</span><br><span class="line">target_include_directories(dynlib PUBLIC /usr/local/cuda/include)</span><br><span class="line">target_compile_options(dynlib PRIVATE -fvisibility=hidden -fvisibility-inlines-hidden)</span><br><span class="line">target_link_directories(dynlib PUBLIC /usr/local/cuda/lib64)</span><br><span class="line">target_link_libraries(dynlib PRIVATE cudart)</span><br></pre></td></tr></table></figure><p>which specifies CUDA architectures with <code>CMAKE_CUDA_ARCHITECTURES</code>. CMake would automatically search for cuda headers and libraries if they are installed on system paths. An old way to trigger CUDA compiling behavior is to use <code>find_package(CUDA)</code>.</p></div><blockquote class="copyright"><p><strong>Link to this article : </strong><a class="permalink" href="https://mrswolf.github.io/learncmake/">https://mrswolf.github.io/learncmake/</a></p><p><strong>This article is available under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a> License</strong></p></blockquote></article></main><aside id="sidebar" class="aside aside-fixture"><div class="toc-sidebar"><nav id="toc" class="article-toc"><h3 class="toc-title">Catalogue</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic"><span class="toc-number">1.</span> <span class="toc-text">Basic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-start"><span class="toc-number">1.1.</span> <span class="toc-text">How to start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-find-headers"><span class="toc-number">1.2.</span> <span class="toc-text">How to find headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-collect-all-sources"><span class="toc-number">1.3.</span> <span class="toc-text">How to collect all sources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-add-definitions"><span class="toc-number">1.4.</span> <span class="toc-text">How to add definitions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-pass-compiler-flags"><span class="toc-number">1.5.</span> <span class="toc-text">How to pass compiler flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-designate-output-folders"><span class="toc-number">1.6.</span> <span class="toc-text">How to designate output folders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-compile-static-libraries"><span class="toc-number">1.7.</span> <span class="toc-text">How to compile static libraries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-compile-shared-libraries"><span class="toc-number">1.8.</span> <span class="toc-text">How to compile shared libraries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-link-libraries"><span class="toc-number">1.9.</span> <span class="toc-text">How to link libraries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-add-library-seaching-paths"><span class="toc-number">1.10.</span> <span class="toc-text">How to add library seaching paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-compile-multiple-targets-on-a-single-CMakeLists"><span class="toc-number">1.11.</span> <span class="toc-text">How to compile multiple targets on a single CMakeLists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-compile-a-CUDA-program"><span class="toc-number">1.12.</span> <span class="toc-text">How to compile a CUDA program</span></a></li></ol></li></ol></nav></div></aside></section><footer class="hidden lg:block fixed bottom-0 left-0 sm:w-1/12 lg:w-1/6 bg-gray-100 z-40"><div class="footer-social-links"><a target="_blank" rel="noopener" href="https://github.com/mrswolf"><i class="iconfont icon-github"></i> </a><a href="/atom.xml"><i class="iconfont icon-rss"></i></a></div></footer><div id="mask" class="hidden mask fixed inset-0 bg-gray-900 opacity-75 z-40"></div><div id="search-view-container" class="hidden shadow-xl"></div><script src="/js/dom-event.min.js"></script><script src="/js/local-search.min.js"></script><script src="//cdn.jsdelivr.net/npm/lightgallery.js@1.1.3/dist/js/lightgallery.min.js"></script><script src="/js/light-gallery.min.js"></script></body></html>